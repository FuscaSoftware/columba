/*
 * The contents of this file are subject to the Mozilla Public License 
 * Version 1.1 (the "License"); you may not use this file except in compliance 
 * with the License. You may obtain a copy of the License at 
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License 
 * for the specific language governing rights and
 * limitations under the License.
 *
 * The Original Code is "Java Security Component Framework"
 *
 * The Initial Developer of the Original Code are Thomas Wabner, alias waffel.
 * Portions created by Thomas Wabner are Copyright (C) 2004. 
 * 
 * All Rights Reserved.
 * Created on 21.01.2004
 *
 */
package org.waffel.jscf;

import java.io.InputStream;

/**
 * The object used for executing a static JSCF statement and returning the
 * results it produces.
 * <p>
 * By default, only one <code>JSCFResultSet</code> object per JSCFStatement
 * object can be open at the same time. Therefore, if the reading of one
 * <code>JSCFResultSet</code> object is interleaved with the reading of
 * another, each must have been generated by different JSCFStatement objects.
 * All execution methods in the JSCFStatement interface implicitly close a
 * statment's current JSCFResultSet object if an open one exists.
 * 
 * @author waffel (Thomas Wabner)
 * @version $Id: JSCFStatement.java,v 1.3 2006/02/06 17:32:32 waffel Exp $
 * @see org.waffel.jscf.JSCFConnection#createStatement()
 * @see org.waffel.jscf.JSCFResultSet
 */
public interface JSCFStatement {

    /**
     * Executes signing the given message with the given userID and password.
     * The default values of "user" and "password" from the connection that
     * creates this statement object, are overriden by the given values.
     * <p>
     * It is not defined if the resulting sign material is a detached sign or a
     * complete sign. This is dependend on the driver you use.
     * <p>
     * The resulting sign stream (or a detached signature) can be obtained by
     * using the <code>JSCFResultSet</code>.
     * 
     * @param message
     *            the message which should be signed. The InputStream is after
     *            use not empty, thus you can use it again in you program.
     * @param userID
     *            the user which would sign the message
     * @param password
     *            the user's password
     * @return a <code>JSCFResultSet</code> object that contains the data
     *         produced by the statement. The result is never null.
     * @throws JSCFException
     *             if a JSCF access error occurs
     */
    JSCFResultSet executeSign(InputStream message, String userID,
            String password) throws JSCFException;

    /**
     * Executes signing the given message with the given password. The default
     * value of "password" from the connection that creates this statement
     * object, are overriden by the give password.
     * <p>
     * It is not defined if the resulting sign material is a detached sign or a
     * complete sign. This is dependend on the driver you use.
     * <p>
     * The resulting sign stream (or a detached signature) can be obtained by
     * using the <code>JSCFResultSet</code>.
     * <p>
     * The required userID is used from the connection for this statement. The
     * userID can be stored direct in the connection or via properties. The
     * property key must be <b>USERID</b>.
     * 
     * @param message
     *            the message which should be signed. The InputStream is after
     *            use not empty, thus you can use it again in you program.
     * @param password
     *            the password for the user which is stored in the connection
     *            which creates this statement object.
     * @return a <code>JSCFResultSet</code> object that contains the data
     *         produced by the statement. The result is never null.
     * @throws JSCFException
     *             if a JSCF access error occurs or the method produces anything
     *             other then a <code>JSCFResultSet</code> object
     */
    JSCFResultSet executeSign(InputStream message, String password)
            throws JSCFException;

    /**
     * Executes signing the given message.
     * <p>
     * It is not defined if the resulting sign material is a detached sign or a
     * complete sign. This is dependend on the driver you use.
     * <p>
     * The resulting sign stream (or a detached signature) can be obtained by
     * using the <code>JSCFResultSet</code>.
     * <p>
     * The required userID is used from the connection for this statement. The
     * userID can be stored direct in the connection or via properties. The
     * property key must be <b>USERID</b>.
     * <p>
     * The required password is used from the connection for this statement. The
     * password can be stored direct in the connection or via properties. The
     * property key must be <b>PASSWORD</b>.
     * 
     * @param message
     *            the message which should be signed. The InputStream is after
     *            use not empty, thus you can use it again in you program.
     * @return a <code>JSCFResultSet</code> object that contains the data
     *         produced by the statement. The result is never null.
     * @throws JSCFException
     *             if a JSCF access error occurs or the method produces anything
     *             other then a <code>JSCFResultSet</code> object
     */
    JSCFResultSet executeSign(InputStream message) throws JSCFException;

    /**
     * Executes verify of the given message with the given signature and the
     * digest algorithm. The default value of "digestAlgortihm" from the
     * connection that creates this statement object, are overriden by the given
     * digest algorithm.
     * 
     * @param message
     *            the message which should be verified with the given signature
     * @param signature
     *            the signature which should be the signature from this message
     *            (if not the <code>JSCFResultSet</code> contains informations
     *            about errors or problems.
     * @param digestAlgorithm
     *            the digest algorithm which should be used to verify the given
     *            message with the given signature.
     * @return a <code>JSCFResultSet</code> object that contains the data
     *         produced by the statement. The result is never null.
     * @throws JSCFException
     *             if a JSCF access error occurs or the method produces anything
     *             other then a <code>JSCFResultSet</code> object
     */
    JSCFResultSet executeVerify(InputStream message, InputStream signature,
            String digestAlgorithm) throws JSCFException;

    /**
     * Executes verify of the given message with the given signature.
     * <p>
     * The required digestAlgorithm is used from the connection for this
     * statement. The digestAlgorithm can be stored direct in the connection or
     * via properties. The property key must be <b>DIGESTALGORITHM</b>.
     * 
     * @param message
     *            the message which should be verified with the given signature
     * @param signature
     *            the signature which should be the signature from this message
     *            (if not the <code>JSCFResultSet</code> contains informations
     *            about errors or problems.
     * @return a <code>JSCFResultSet</code> object that contains the data
     *         produced by the statement. The result is never null.
     * @throws JSCFException
     *             if a JSCF access error occurs or the method produces anything
     *             other then a <code>JSCFResultSet</code> object
     */
    JSCFResultSet executeVerify(InputStream message, InputStream signature)
            throws JSCFException;

    /**
     * Executes encrypting the given message for the given recipients. The
     * default value of "recipients" from the connection that creates this
     * statement object, are overriden by the given recipients.
     * <p>
     * Recipients schould be seperated by whitespaces, but this is driver
     * dependend.
     * 
     * @param message
     *            the message which should be encrypted for the given recipients
     * @param recipients
     *            the recipients for which the given message should be
     *            encrpyted. The recipients should be seperated by whitespaces,
     *            but this is driver dependend.
     * @return a <code>JSCFResultSet</code> object that contains the data
     *         produced by the statement. The result is never null.
     * @throws JSCFException
     *             if a JSCF access error occurs or the method produces anything
     *             other then a <code>JSCFResultSet</code> object
     */
    JSCFResultSet executeEncrypt(InputStream message, String recipients)
            throws JSCFException;

    /**
     * Executes encrypting the given message.
     * <p>
     * The required recipient list is used from the connection for this
     * statement. The recipient list can be stored direct in the connection or
     * via properties. The property key must be <b>RECIPIENTS</b>. The
     * recipients should be seperated by whitespaces, but this is driver
     * dependend.
     * 
     * @param message
     *            the message which should be encrypted for the recipients. the
     *            recipient list is obtained from the connection which creates
     *            the statement.
     * @return a <code>JSCFResultSet</code> object that contains the data
     *         produced by the statement. The result is never null.
     * @throws JSCFException
     *             if a JSCF access error occurs or the method produces anything
     *             other then a <code>JSCFResultSet</code> object
     */
    JSCFResultSet executeEncrypt(InputStream message) throws JSCFException;

    /**
     * Executes decrypting the given message with the given password. The
     * default value of "password" from the connection that creates this
     * statement object, are overriden by the given password.
     * <p>
     * The decrypted message stream can be obtained by using the
     * <code>JSCFResultSet</code>.
     * 
     * @param message
     *            the message which should be decrypted with the given password.
     * @param password
     *            the password which is needed to decrypt the message.
     * @return a <code>JSCFResultSet</code> object that contains the data
     *         produced by the statement. The result is never null.
     * @throws JSCFException
     *             if a JSCF access error occurs or the method produces anything
     *             other then a <code>JSCFResultSet</code> object
     */
    JSCFResultSet executeDecrypt(InputStream message, String password)
            throws JSCFException;

    /**
     * Executes decrypting the given message.
     * <p>
     * The decrypted message stream can be obtained by using the
     * <code>JSCFResultSet</code>.
     * <p>
     * The required password is used from the connection for this statement. The
     * password can be stored direct in the connection or via properties. The
     * property key must be <b>PASSWORD</b>.
     * 
     * @param message
     *            the message which should be decrypted with the password from
     *            the connection which creates the statement object.
     * @return a <code>JSCFResultSet</code> object that contains the data
     *         produced by the statement. The result is never null.
     * @throws JSCFException
     *             if a JSCF access error occurs or the method produces anything
     *             other then a <code>JSCFResultSet</code> object
     */
    JSCFResultSet executeDecrypt(InputStream message) throws JSCFException;

    /**
     * Checks if the JSCF implementation can sign a test string with the given
     * password. The user which is used to sign the testmessage is used from the
     * connection which creates the statement. If the user can sign a
     * testmessage with the given password, then the user can using the JSCF
     * Driver without problems with the password.
     * <p>
     * The required userID is used from the connection for this statement. The
     * userID can be stored direct in the connection or via properties. The
     * property key must be <b>USERID</b>.
     * 
     * @param password
     *            the password which is used to sign a test message.
     * @return true if the user can sign a test message, else false
     * @throws JSCFException
     *             if a JSCF access error occurs or signing of the testmessage
     *             has other problems then to create a
     *             <code>JSCFResultSet</code> object
     */
    boolean checkPassphrase(String password) throws JSCFException;

    /**
     * Checks if the JSCF implementation can sign a test string. The password
     * and user are used to sign the testmessage is used from the connection
     * which creates the statement. If the user can sign a testmessage with the
     * given password, then the user can using the JSCF Driver without problems.
     * <p>
     * The required userID is used from the connection for this statement. The
     * userID can be stored direct in the connection or via properties. The
     * property key must be <b>USERID</b>.
     * <p>
     * The required password is used from the connection for this statement. The
     * password can be stored direct in the connection or via properties. The
     * property key must be <b>PASSWORD</b>.
     * 
     * @return true if the user can sign a test message, else false
     * @throws JSCFException
     *             if a JSCF access error occurs or signing of the testmessage
     *             has other problems then to create a
     *             <code>JSCFResultSet</code> object
     */
    boolean checkPassphrase() throws JSCFException;

}
